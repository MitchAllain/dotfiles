#!/bin/bash

# #   ROS aliases
alias rosenv='printenv | grep -i ROS'
alias rosgdb="rosrun --prefix 'gdb -ex run --args' "
alias rosprofile="rosrun --prefix 'valgrind --tool=callgrind' "
alias rosmemcheck="rosrun --prefix 'valgrind --tool=memcheck' "

# Set the logger level for a ROS node
# Args:
#    $1: node name
#    $2: logger name
#    $3: log level
#
# Example: 'rosloglvl ultra_workspace_manager rospy debug'
rosloglvl () {
    rosservice call "$2"/set_logger_level "logger='ros.$1'"$'\r'"level='$3'"
}

# Reset any overlays by sourcing the default ROS environment, then source
# the workspace containing the current directory, if any.
sws () {
    # shellcheck source=/opt/ros/noetic/setup.bash
    source /opt/ros/"$ROS_DISTRO"/setup.bash;
    local wspath
    wspath="$(catkin locate 2>/dev/null)"

    # check if in a workspace and setup.bash exists
    if [ -n "$wspath" ] && [ -f "$wspath"/devel/setup.bash ]; then
        # shellcheck source=/home/mallain/catkin_ws/devel/setup.bash
        source "$wspath"/devel/setup.bash;
    fi
}

# Update 'rostopic list' every 1 second, or n seconds where n is arg 1
# Args:
#   $1: (optional: default 1) period in seconds
#
# Example: 'rostopicw 2'
rostopicw () {
    local period=${1:-1}
    watch -n "$period" "rostopic list"
}

# Update 'rosnode list' every 1 second, or n seconds where n is arg 1
# Args:
#  $1: (optional: default 1) period in seconds
#
# Example: 'rosnodew 2'
rosnodew () {
    local period=${1:-"1"}
    watch -n "$period" "rosnode list"
}

# Replace rosmaster hostname with arg 1, assume default port
# Args:
#     $1: hostname
#     $2: (optional, default '11311') port
#
# Example: 'rosmaster robot'
rosmaster () {
    local port=${2:-"11311"}
    export ROS_MASTER_URI=http://$1:$port
}

# Search package names and paths for pattern
# Args:
#    $1: pattern to search for
#
# Example: 'rosgrep sensor'
rosgrep () {
    rospack list | grep "$1";
}

# Republish a Quaternion as Vector3 with Euler angles in degrees on /eulerify/<topic>
# Args:
#     $1: Quaternion topic to republish, or quaternion field in a message
#     e.g. '/<topic>/pose/orientation'
#
# Example: 'roseulerify /pose/pose/orientation'
roseulerify () {
    rosrun topic_tools transform "$1" /eulerify/"$1" geometry_msgs/Vector3 \
        'map(lambda x: x * 57.296, tf.transformations.euler_from_quaternion([m.x, m.y, m.z, m.w]))' --import tf
}

# Parse ros wiki url from package.xml and open in chrome
# Args:
#    $1: package name
#
# Example: 'roswiki robot_localization'
roswiki () {
    local pkgxml
    pkgxml=$(rospack find "$1")/package.xml
    local url
    url=$(cat "$pkgxml" | grep http | cut -d ">" -f 2 | cut -d "<" -f 1)

    # open in chrome in the background, suppress output
    google-chrome "$url" > /dev/null 2>&1 &
}

# Build package name from first arg and execute tests, printing results
# Args:
#   $1: package name
catkin_test() {
    local wspath
    wspath=$(catkin locate)
    catkin build --no-deps --catkin-make-args run_tests -- "$1" > /dev/null \
        && catkin_test_results "$wspath"/build/"$1"
}

# Build current package and execute tests, printing results
catkin_test_this() {
    local pkgname
    pkgname=$(catkin list --this -u)
    catkin_test "$pkgname"
}

# Source containing workspace without clearing ros env, i.e. overlay ws
catkin_source() {
    local wspath
    wspath=$(catkin locate 2>/dev/null)
    if [ -n "$wspath" ] && [ -f "$wspath"/devel/setup.bash ]; then
        # shellcheck source=/home/mallain/catkin_ws/devel/setup.bash
        source "$wspath"/devel/setup.bash
    else
        echo "Not in a catkin workspace"
    fi
}

# compdb is a tool that manipulates compilation databases generated by CMake
if [[ -n $(command -v compdb) ]]; then
    # Collect all translation dbs from all packages in the workspace and link to src
    # This may require a clean build to ensure all translation dbs are generated
    # but that is left to the user to decide
    # Args:
    #     $@: additional arguments to pass to catkin build
    #
    # Example: 'catkin clean -y && wscompdb'
    link_compdb() {
        local wspath
        wspath=$(catkin locate 2>/dev/null)
        if [ -n "$wspath" ]; then
            local packages
            packages=$(catkin list -u)
            local dbs=""
            for pack in $packages
            do
                if [ -f "$wspath"/build/"$pack"/compile_commands.json ]; then
                    dbs="$dbs -p $wspath/build/$pack"
                else
                    echo "No translation db for $pack"
                fi
            done
            # shellcheck disable=SC2086
            compdb $dbs list > "$wspath"/src/compile_commands.json \
                && echo "Compilation database created at $wspath/src/compile_commands.json"
        else
            echo "Not in a catkin workspace"
        fi
    }

    build_compdb() {
        catkin build --cmake-args -DCMAKE_EXPORT_COMPILE_COMMANDS=ON "$@"
    }
fi

# Play a rosbag with simulated time
rosbag_simtime() {
    rosparam set /use_sim_time true
    rosbag play "$1" -l --clock
}

# Try to find the package path using rospack and catkin tools. If the package
#     is not found, return the package name.
# Args:
#     $1  ROS package name
rospackpath() {
    if rospack find "$1" > /dev/null 2>&1; then
        rospack find "$1"
    elif catkin locate "$1" > /dev/null 2>&1; then
        # otherwise, use catkin locate (local workspace package search)
        catkin locate "$1"
    else
        echo "$1"
    fi
}

# entr - automatic execution of commands using kqueue or inotify
if [ -x "$(command -v entr)" ]; then

    # Re-execute all pytests within a ROS package when any test file is updated.
    # Args:
    #     $1      ROS package name
    #     ${@:2}  Additional args are passed to pytest
    entr_pytest_rospack() {
        local packpath
        packpath="$(rospackpath "$1")"
        find "$packpath"/test -name "test*.py" | entr -c pytest "${@:2}" "$packpath"
    }

    # Re-execute a pytest when the test*.py file is updated
    # Args:
    #     $1      Path to a pytest test*.py file
    #     ${@:2}  Additional args are passed to pytest
    entr_pytest() {
        echo "$1" | entr -c pytest "${@:2}" "$1"
    }

    # Execute catkin test when any test*.py or test*.launch file is updated.
    # Args:
    #     $1      ROS Package name
    #     ${@:2}  Additional args are passed to catkin test
    entr_test_rospack() {
        local packpath
        packpath="$(rospackpath "$1")"
        find "$packpath"/test -name "test*.py" -o -name "test*.launch" | entr -c catkin test "${@:2}" "$1"
    }
fi


